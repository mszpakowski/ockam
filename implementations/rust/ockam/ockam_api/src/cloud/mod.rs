use tracing::trace;

use ockam::{
    authenticated_storage::InMemoryStorage,
    identity::{Identity, IdentityVault, TrustEveryonePolicy},
    route,
};
use ockam_core::{self, Address, Route};
use ockam_node::Context;

use crate::auth::types::Attributes;
use crate::cloud::enroll::{auth0::*, enrollment_token::*, *};
use crate::cloud::invitation::{CreateInvitation, Invitation};
use crate::cloud::project::{CreateProject, Project};
use crate::cloud::space::{CreateSpace, Space};
use crate::Request;
use crate::{decode, is_ok, request};

pub mod enroll;
pub mod invitation;
pub mod project;
pub mod space;

const TARGET: &str = "ockam_api::cloud::client";

pub struct MessagingClient {
    ctx: Context,

    /// Address of the secure channel local endpoint
    channel: Address,

    buf: Vec<u8>,
}

impl MessagingClient {
    pub async fn new<V: IdentityVault>(
        route: Route,
        identity: Identity<V>,
        ctx: &Context,
    ) -> ockam_core::Result<Self> {
        let ctx = ctx.new_detached(Address::random_local()).await?;

        // Create an AuthenticatedStorage to store info about Sender's known Identities.
        let storage = InMemoryStorage::new();

        // As Sender, connect to the Ockam Orchestrator secure channel listener, and perform an
        // Authenticated Key Exchange to establish an encrypted secure channel with its api
        // endpoint.
        // TODO: verify server' identity (pubkey hardcoded on ockam-command)
        let channel = identity
            .create_secure_channel(route.clone(), TrustEveryonePolicy, &storage)
            .await?;
        Ok(MessagingClient {
            ctx,
            channel,
            buf: Vec::new(),
        })
    }

    /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
    pub async fn enroll_auth0<'a, S>(&mut self, mut auth0_service: S) -> ockam_core::Result<()>
    where
        S: Auth0TokenProvider<'a, T = Auth0Token<'a>>,
    {
        trace!(target = %TARGET, "executing auth0 flow");
        let token = {
            let token = auth0_service.token().await?;
            AuthenticateToken::Auth0(AuthenticateAuth0Token::new(token))
        };
        self.authenticate_token(token).await?;
        Ok(())
    }

    /// Generates a token that will be associated to the passed attributes.
    pub async fn generate_enrollment_token(
        &mut self,
        attributes: Attributes<'_>,
    ) -> ockam_core::Result<EnrollmentToken<'static>> {
        let label = "enrollment_token_generator";
        trace!(target = %TARGET, "generating tokens");

        let body = RequestEnrollmentToken::new(attributes);
        let req = Request::post("v0/").body(body);
        let route = self.api_service_route("enrollment_token_authenticator");
        // TODO: change `schema` to `attributes` after secure channels are enabled (identifier arg is not used)
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, None, &self.buf)
    }

    /// Authenticates a token generated by `generate_enrollment_token`.
    pub async fn authenticate_enrollment_token(
        &mut self,
        token: EnrollmentToken<'_>,
    ) -> ockam_core::Result<()> {
        trace!(target = %TARGET, "authenticating token");
        let token = AuthenticateToken::EnrollmentToken(AuthenticateEnrollmentToken::new(token));
        self.authenticate_token(token).await?;
        Ok(())
    }

    async fn authenticate_token(&mut self, body: AuthenticateToken<'_>) -> ockam_core::Result<()> {
        // TODO: add AuthenticateAuth0Token to schema.cddl and use it here
        let schema = None;
        let label;
        match body {
            AuthenticateToken::Auth0(body) => {
                label = "auth0_authenticator";
                let route = self.api_service_route(label);
                let req = Request::post("v0/enroll").body(body);
                self.buf = request(&mut self.ctx, TARGET, label, schema, route, &req).await?;
            }
            AuthenticateToken::EnrollmentToken(body) => {
                label = "enrollment_token_authenticator";
                let route = self.api_service_route(label);
                let req = Request::post("v0/enroll").body(body);
                self.buf = request(&mut self.ctx, TARGET, label, schema, route, &req).await?;
            }
        };
        is_ok(TARGET, label, &self.buf)
    }

    pub async fn create_invitation(
        &mut self,
        body: CreateInvitation<'_>,
    ) -> ockam_core::Result<Invitation<'_>> {
        let label = "create_invitation";
        trace!(target = TARGET, space = ?body.space_id, "creating invitation");

        let route = self.api_service_route("invitations");
        let req = Request::post("v0/").body(body);
        self.buf = request(
            &mut self.ctx,
            TARGET,
            label,
            "create_invitation",
            route,
            &req,
        )
        .await?;
        decode(TARGET, label, "invitation", &self.buf)
    }

    pub async fn list_invitations(&mut self) -> ockam_core::Result<Vec<Invitation<'_>>> {
        let label = "list_invitations";
        trace!(target = %TARGET, "listing invitations");

        let route = self.api_service_route("invitations");
        let req = Request::get("v0/");
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "invitations", &self.buf)
    }

    pub async fn accept_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let label = "accept_invitation";
        trace!(target = %TARGET, "accept invitation");

        let route = self.api_service_route("invitations");
        let req = Request::put(format!("v0/{invitation_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        is_ok(TARGET, label, &self.buf)
    }

    pub async fn reject_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let label = "reject_invitation";
        trace!(target = %TARGET, "reject invitation");

        let route = self.api_service_route("invitations");
        let req = Request::delete(format!("v0/{invitation_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        is_ok(TARGET, label, &self.buf)
    }

    pub async fn create_space(&mut self, body: CreateSpace<'_>) -> ockam_core::Result<Space<'_>> {
        let label = "create_space";
        trace!(target = %TARGET, space = %body.name, "creating space");

        let route = self.api_service_route("spaces");
        let req = Request::post("v0/").body(body);
        self.buf = request(&mut self.ctx, TARGET, label, "create_space", route, &req).await?;
        decode(TARGET, label, "space", &self.buf)
    }

    pub async fn list_spaces(&mut self) -> ockam_core::Result<Vec<Space<'_>>> {
        let label = "list_spaces";
        trace!(target = %TARGET, "listing spaces");

        let route = self.api_service_route("spaces");
        let req = Request::get("v0/");
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "spaces", &self.buf)
    }

    pub async fn get_space(&'_ mut self, space_id: &str) -> ockam_core::Result<Space<'_>> {
        let label = "get_space";
        trace!(target = %TARGET, space = %space_id, space = %space_id, "getting space");

        let route = self.api_service_route("spaces");
        let req = Request::get(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "space", &self.buf)
    }

    pub async fn get_space_by_name(&mut self, space_name: &str) -> ockam_core::Result<Space<'_>> {
        let label = "get_space_by_name";
        trace!(target = %TARGET, space = %space_name, "getting space");

        let route = self.api_service_route("spaces");
        let req = Request::get(format!("v0/name/{space_name}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "space", &self.buf)
    }

    pub async fn delete_space(&mut self, space_id: &str) -> ockam_core::Result<()> {
        let label = "delete_space";
        trace!(target = %TARGET, space = %space_id, "deleting space");

        let route = self.api_service_route("spaces");
        let req = Request::delete(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        is_ok(TARGET, label, &self.buf)
    }

    pub async fn create_project(
        &mut self,
        space_id: &str,
        body: CreateProject<'_>,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "create_project";
        trace!(target = %TARGET, space = %space_id, project = %body.name, "creating project");

        let route = self.api_service_route("projects");
        let req = Request::post(format!("v0/{space_id}")).body(body);
        self.buf = request(&mut self.ctx, TARGET, label, "create_project", route, &req).await?;
        decode(TARGET, label, "project", &self.buf)
    }

    pub async fn list_projects(&mut self, space_id: &str) -> ockam_core::Result<Vec<Project<'_>>> {
        let label = "list_projects";
        trace!(target = %TARGET, space = %space_id, "listing projects");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "projects", &self.buf)
    }

    pub async fn get_project(
        &'_ mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "get_project";
        trace!(target = %TARGET, space = %space_id, project = %project_id, "getting project");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}/{project_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "project", &self.buf)
    }

    pub async fn get_project_by_name(
        &'_ mut self,
        space_id: &str,
        project_name: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "get_project_by_name";
        trace!(target = %TARGET, space = %space_id, project = %project_name, "getting project");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}/name/{project_name}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        decode(TARGET, label, "project", &self.buf)
    }

    pub async fn delete_project(
        &mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<()> {
        let label = "delete_project";
        trace!(target = %TARGET, space = %space_id, project = %project_id, "deleting project");

        let route = self.api_service_route("projects");
        let req = Request::delete(format!("v0/{space_id}/{project_id}"));
        self.buf = request(&mut self.ctx, TARGET, label, None, route, &req).await?;
        is_ok(TARGET, label, &self.buf)
    }

    fn api_service_route(&self, api_service: &str) -> Route {
        route![self.channel.clone(), api_service]
    }
}
